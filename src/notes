package com.industry.Rendering;

import net.minecraft.client.render.RenderLayer;
import net.minecraft.client.render.VertexConsumer;
import net.minecraft.client.render.VertexConsumerProvider;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.Vec3d;
import org.joml.Matrix4f;

public class RenderUtil {

    // --- Renders a single triangle with proper normal and UV mapping ---
    public static void renderTriangle(VertexConsumer vertexConsumer, Matrix4f matrix,
                                      Vec3d p1, Vec3d p2, Vec3d p3,
                                      float u1, float v1,
                                      float u2, float v2,
                                      float u3, float v3,
                                      float r, float g, float b, float a) {

        Vec3d edge1 = p2.subtract(p1);
        Vec3d edge2 = p3.subtract(p1);
        Vec3d normalVec = edge1.crossProduct(edge2).normalize();

        float nx = (float) normalVec.x;
        float ny = (float) normalVec.y;
        float nz = (float) normalVec.z;

        vertexConsumer.vertex(matrix, (float) p1.x, (float) p1.y, (float) p1.z)
                .color(r, g, b, a)
                .texture(u1, v1)
                .overlay(0, 0)
                .light(0xF000F0, 0xF000F0)
                .normal(nx, ny, nz);

        vertexConsumer.vertex(matrix, (float) p2.x, (float) p2.y, (float) p2.z)
                .color(r, g, b, a)
                .texture(u2, v2)
                .overlay(0, 0)
                .light(0xF000F0, 0xF000F0)
                .normal(nx, ny, nz);

        vertexConsumer.vertex(matrix, (float) p3.x, (float) p3.y, (float) p3.z)
                .color(r, g, b, a)
                .texture(u3, v3)
                .overlay(0, 0)
                .light(0xF000F0, 0xF000F0)
                .normal(nx, ny, nz);
    }

    // --- Renders a quad using two triangles, with correct UV mapping ---
    public static void renderQuad(VertexConsumer vertexConsumer, Matrix4f matrix,
                                  Vec3d a, Vec3d b, Vec3d c, Vec3d d,
                                  float r, float g, float bCol, float aCol) {
        // Triangle 1: a-b-c
        renderTriangle(vertexConsumer, matrix, a, b, c,
                0f, 0f,
                0f, 1f,
                1f, 1f,
                r, g, bCol, aCol);
        // Triangle 2: a-c-d
        renderTriangle(vertexConsumer, matrix, a, c, d,
                0f, 0f,
                1f, 1f,
                1f, 0f,
                r, g, bCol, aCol);
    }

    // --- Renders a textured box given 8 corner points ---
    public static void renderBox(VertexConsumerProvider vertexConsumers, Matrix4f matrix,
                                 Identifier texture,
                                 Vec3d p1, Vec3d p2, Vec3d p3, Vec3d p4,
                                 Vec3d p5, Vec3d p6, Vec3d p7, Vec3d p8,
                                 float r, float g, float b, float a) {

        VertexConsumer vertexConsumer = vertexConsumers.getBuffer(RenderLayer.getEntityTranslucent(texture));

        // Front face (z+)
        renderQuad(vertexConsumer, matrix, p1, p2, p3, p4, r, g, b, a);
        // Back face (z-)
        renderQuad(vertexConsumer, matrix, p5, p6, p7, p8, r, g, b, a);
        // Left face (x-)
        renderQuad(vertexConsumer, matrix, p1, p5, p8, p4, r, g, b, a);
        // Right face (x+)
        renderQuad(vertexConsumer, matrix, p2, p6, p7, p3, r, g, b, a);
        // Top face (y+)
        renderQuad(vertexConsumer, matrix, p4, p3, p7, p8, r, g, b, a);
        // Bottom face (y-)
        renderQuad(vertexConsumer, matrix, p1, p2, p6, p5, r, g, b, a);
    }
}
